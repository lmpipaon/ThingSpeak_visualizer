import 'dart:math';
import 'dart:ui' as ui;
import 'package:flutter/material.dart';
import 'package:intl/intl.dart';
import 'package:fl_chart/fl_chart.dart';
import 'package:shared_preferences/shared_preferences.dart';

// Asegúrate de que estas rutas coincidan exactamente con tu estructura de carpetas
import '../models/chart_data.dart';
import '../models/chart_source.dart';
import '../models/favorite_config.dart';
import '../services/thingspeak_service.dart';
import '../constants/app_constants.dart';
import '../localization/translations.dart';

// ------------------- PAINTER DE EJES Y (MULTIESCALA EXTERNA) -------------------
class YAxisPainter extends CustomPainter {
  final double minY;
  final double maxY;
  final double width;
  final Color color;

  YAxisPainter({
    required this.minY,
    required this.maxY,
    required this.width,
    required this.color,
  });

  double normalize(double value) => (maxY == minY) ? 0.5 : (value - minY) / (maxY - minY);

  @override
  void paint(Canvas canvas, Size size) {
    final paintGrid = Paint()..color = color.withOpacity(0.1)..strokeWidth = 0.5;
    final paintLine = Paint()..color = color..strokeWidth = 2;

    final values = [minY, minY + (maxY - minY) * 0.5, maxY];

    for (var v in values) {
      final y = size.height * (1 - normalize(v));
      canvas.drawLine(Offset(width - 5, y), Offset(size.width * 20, y), paintGrid);

      final tp = TextPainter(
        text: TextSpan(
          text: v.toStringAsFixed(1),
          style: TextStyle(color: color, fontSize: 11, fontWeight: FontWeight.bold),
        ),
        textAlign: TextAlign.right,
        textDirection: ui.TextDirection.ltr,
      )..layout(maxWidth: width - 8);
      
      tp.paint(canvas, Offset(0, y - tp.height / 2));
    }
    // Línea vertical separadora de cada escala
    canvas.drawLine(Offset(size.width, 0), Offset(size.width, size.height), paintLine);
  }

  @override
  bool shouldRepaint(covariant CustomPainter oldDelegate) => true;
}

// ------------------- PANTALLA PRINCIPAL -------------------
class MultiFieldChartScreen extends StatefulWidget {
  final List<ChartSource> sources;
  final DateTime start;
  final DateTime end;
  final String language;
  final Map<String, double?>? initialMin;
  final Map<String, double?>? initialMax;

  const MultiFieldChartScreen({
    super.key,
    required this.sources,
    required this.start,
    required this.end,
    required this.language,
    this.initialMin,
    this.initialMax,
  });

  @override
  State<MultiFieldChartScreen> createState() => _MultiFieldChartScreenState();
}

class _MultiFieldChartScreenState extends State<MultiFieldChartScreen> {
  late DateTime startDate;
  late DateTime endDate;
  bool _isLoadingData = true;
  final ThingSpeakService service = ThingSpeakService();
  
  Map<String, List<ChartData>> multiData = {};
  List<ChartData> widestDataList = [];
  RangeValues? xRange;

  final Map<String, double?> minValues = {};
  final Map<String, double?> maxValues = {};
  final Map<String, TextEditingController> minControllers = {};
  final Map<String, TextEditingController> maxControllers = {};
  Map<String, bool> serieVisible = {};

  @override
  void initState() {
    super.initState();
    startDate = widget.start;
    endDate = widget.end;
    
    for (var s in widget.sources) {
      minValues[s.id] = widget.initialMin?[s.id];
      maxValues[s.id] = widget.initialMax?[s.id];
      minControllers[s.id] = TextEditingController(text: minValues[s.id]?.toString() ?? '');
      maxControllers[s.id] = TextEditingController(text: maxValues[s.id]?.toString() ?? '');
      serieVisible[s.id] = true;
    }
    fetchData();
  }

  @override
  void dispose() {
    for (var c in minControllers.values) c.dispose();
    for (var c in maxControllers.values) c.dispose();
    super.dispose();
  }

  // MÉTODO FETCH CORREGIDO: Resetea todo para sincronizar nuevas fechas
  Future<void> fetchData() async {
    if (!mounted) return;
    setState(() {
      _isLoadingData = true;
      multiData.clear();
      widestDataList.clear();
      xRange = null; // IMPORTANTE: Resetea el zoom al cambiar fechas
    });

    try {
      for (var s in widget.sources) {
        final data = await service.getFieldValuesWithTime(
          s.channel, s.fieldX, start: startDate, end: endDate, results: 800,
        );
        multiData[s.id] = data;
      }

      int maxLen = 0;
      for (var l in multiData.values) if (l.length > maxLen) maxLen = l.length;
      
      if (maxLen > 0) {
        widestDataList = multiData.values.firstWhere((l) => l.length == maxLen);
        setState(() {
          xRange = RangeValues(0, (maxLen - 1).toDouble());
        });
      }
    } catch (e) {
      debugPrint("Error en descarga: $e");
    } finally {
      if (mounted) setState(() => _isLoadingData = false);
    }
  }

  // ---------------- CONSTRUCCIÓN DE GRÁFICA ----------------
  Widget _buildChart() {
    if (xRange == null || widestDataList.isEmpty) {
      return const Center(child: Text("Sin datos en este rango"));
    }

    final List<LineChartBarData> lines = [];
    for (var s in widget.sources) {
      if (serieVisible[s.id] != true) continue;
      final data = multiData[s.id] ?? [];
      if (data.isEmpty) continue;

      final minY = minValues[s.id] ?? data.map((e) => e.value).reduce(min);
      final maxY = maxValues[s.id] ?? data.map((e) => e.value).reduce(max);
      
      final startIdx = xRange!.start.toInt();
      final endIdx = xRange!.end.toInt();

      final spots = data.asMap().entries
          .where((e) => e.key >= startIdx && e.key <= endIdx)
          .map((e) => FlSpot(
                e.key.toDouble(), 
                (maxY == minY) ? 0.5 : (e.value.value - minY) / (maxY - minY)
              ))
          .toList();

      lines.add(LineChartBarData(
        spots: spots, isCurved: true, color: s.color, barWidth: 3, dotData: const FlDotData(show: false),
      ));
    }

    return LineChart(
      LineChartData(
        minY: 0, maxY: 1,
        lineBarsData: lines,
        gridData: FlGridData(show: true, horizontalInterval: 0.25, getDrawingHorizontalLine: (_) => FlLine(color: Colors.black12)),
        borderData: FlBorderData(show: true, border: Border.all(color: Colors.black26)),
        titlesData: FlTitlesData(
          show: true,
          topTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          rightTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          leftTitles: const AxisTitles(sideTitles: SideTitles(showTitles: false)),
          bottomTitles: AxisTitles(
            sideTitles: SideTitles(
              showTitles: true,
              reservedSize: 30,
              interval: (widestDataList.length / 5).clamp(1, 9999).toDouble(),
              getTitlesWidget: (value, meta) {
                int idx = value.toInt();
                if (idx >= 0 && idx < widestDataList.length) {
                  return SideTitleWidget(
                    axisSide: meta.axisSide,
                    child: Text(DateFormat('HH:mm').format(widestDataList[idx].time), style: const TextStyle(fontSize: 10)),
                  );
                }
                return const SizedBox.shrink();
              },
            ),
          ),
        ),
        lineTouchData: LineTouchData(
          touchTooltipData: LineTouchTooltipData(
            getTooltipColor: (group) => Colors.white.withOpacity(0.9),
            getTooltipItems: (spots) => spots.map((s) {
              final serie = widget.sources[s.barIndex];
              final list = multiData[serie.id]!;
              if (s.x.toInt() >= list.length) return null;
              return LineTooltipItem('${serie.displayName}\n${list[s.x.toInt()].value.toStringAsFixed(2)}', 
                TextStyle(color: serie.color, fontWeight: FontWeight.bold));
            }).toList(),
          ),
        ),
      ),
    );
  }

  Widget _buildChartArea() {
    return LayoutBuilder(builder: (context, constraints) {
      const double axisWidth = 46.0;
      int visibleCount = widget.sources.where((s) => serieVisible[s.id] == true).length;
      final double leftPadding = visibleCount * axisWidth;

      return Stack(
        clipBehavior: Clip.none,
        children: [
          Padding(
            padding: EdgeInsets.only(left: leftPadding + 10, right: 20, bottom: 5),
            child: _buildChart(),
          ),
          ..._buildYAxes(axisWidth),
        ],
      );
    });
  }

  List<Widget> _buildYAxes(double width) {
    int index = 0;
    return widget.sources.where((s) => serieVisible[s.id] == true).map((s) {
      final data = multiData[s.id] ?? [];
      if (data.isEmpty) return const SizedBox.shrink();
      final minY = minValues[s.id] ?? data.map((e) => e.value).reduce(min);
      final maxY = maxValues[s.id] ?? data.map((e) => e.value).reduce(max);
      final left = (index++).toDouble() * width;

      return Positioned(
        left: left, top: 0, bottom: 35, // Espacio para el eje X
        child: CustomPaint(
          size: Size(width, 0),
          painter: YAxisPainter(minY: minY, maxY: maxY, width: width, color: s.color),
        ),
      );
    }).toList();
  }

  // ---------------- UI BUILD ----------------
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(title: const Text('ThingSpeak Multiescala'), actions: [
        IconButton(icon: const Icon(Icons.tune), onPressed: _showYAxisSettings),
        IconButton(icon: const Icon(Icons.refresh), onPressed: fetchData),
      ]),
      body: Column(children: [
        _buildDateHeader(),
        _buildVisibilityToggles(),
        Expanded(
          child: _isLoadingData 
            ? const Center(child: CircularProgressIndicator()) 
            : Padding(padding: const EdgeInsets.only(top: 20), child: _buildChartArea())
        ),
        if (xRange != null && widestDataList.isNotEmpty) _buildZoomSlider(),
      ]),
    );
  }

  Widget _buildDateHeader() => Padding(
    padding: const EdgeInsets.all(8),
    child: Row(children: [
      Expanded(child: ActionChip(onPressed: () => _selectDate(true), label: Text('De: ${DateFormat('dd/MM HH:mm').format(startDate)}'))),
      const SizedBox(width: 8),
      Expanded(child: ActionChip(onPressed: () => _selectDate(false), label: Text('A: ${DateFormat('dd/MM HH:mm').format(endDate)}'))),
    ]),
  );

  Widget _buildVisibilityToggles() => SingleChildScrollView(
    scrollDirection: Axis.horizontal,
    child: Row(children: widget.sources.map((s) => Row(children: [
      Checkbox(value: serieVisible[s.id], onChanged: (v) => setState(() => serieVisible[s.id] = v ?? true), activeColor: s.color),
      Text(s.displayName, style: TextStyle(color: s.color, fontWeight: FontWeight.bold)),
      const SizedBox(width: 15),
    ])).toList()),
  );

  Widget _buildZoomSlider() => Padding(
    padding: const EdgeInsets.symmetric(horizontal: 20, vertical: 10),
    child: RangeSlider(
      values: xRange!, min: 0, max: (widestDataList.length - 1).toDouble().clamp(1, 99999),
      onChanged: (v) => setState(() => xRange = v),
    ),
  );

  Future<void> _selectDate(bool start) async {
    final d = await showDatePicker(context: context, initialDate: start ? startDate : endDate, firstDate: DateTime(2020), lastDate: DateTime.now());
    if (d == null) return;
    final t = await showTimePicker(context: context, initialTime: TimeOfDay.fromDateTime(start ? startDate : endDate));
    if (t == null) return;
    setState(() {
      final nd = DateTime(d.year, d.month, d.day, t.hour, t.minute);
      if (start) startDate = nd; else endDate = nd;
    });
    fetchData(); // Esto refresca el gráfico con el nuevo rango
  }

  void _showYAxisSettings() {
    showDialog(context: context, builder: (context) => AlertDialog(
      title: const Text('Ajustar Escalas Y'),
      content: SingleChildScrollView(child: Column(mainAxisSize: MainAxisSize.min, children: widget.sources.map((s) => Column(children: [
        Text(s.displayName, style: TextStyle(color: s.color, fontWeight: FontWeight.bold)),
        Row(children: [
          Expanded(child: TextField(controller: minControllers[s.id], decoration: const InputDecoration(labelText: 'Min'), keyboardType: TextInputType.number)),
          const SizedBox(width: 10),
          Expanded(child: TextField(controller: maxControllers[s.id], decoration: const InputDecoration(labelText: 'Max'), keyboardType: TextInputType.number)),
        ]),
        const Divider(),
      ])).toList())),
      actions: [TextButton(onPressed: () {
        setState(() {
          for (var s in widget.sources) {
            minValues[s.id] = double.tryParse(minControllers[s.id]!.text);
            maxValues[s.id] = double.tryParse(maxControllers[s.id]!.text);
          }
        });
        Navigator.pop(context);
      }, child: const Text('Aplicar'))],
    ));
  }
}